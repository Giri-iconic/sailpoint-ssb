<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE Rule PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<Rule language="beanshell" name="All Application Test Connection Check Executor">
  <Source><![CDATA[

  import sailpoint.object.*;
  import sailpoint.object.SailPointObject;
  import sailpoint.object.PasswordPolicy;
  import sailpoint.object.PasswordPolicyHolder;	
  import java.lang.reflect.Constructor;
  import sailpoint.tools.Message;		
  import sailpoint.connector.Connector;
  import sailpoint.connector.ConnectorFactory;
  import java.util.List;
  import java.lang.Class; 
  import org.apache.commons.lang.StringUtils;
  import java.util.concurrent.*;
  import java.util.concurrent.Callable;
  import sailpoint.api.SailPointContext;
  import sailpoint.api.SailPointFactory;

  String applicationName="";
  String applicationStatus="";

  //Method to check application test connection
  /*	  public String checkApplicationConnection(Application application) {
    String status;

    // Perform context-dependent operations in the main thread
    Connector conn = null;
    try {
        conn = ConnectorFactory.getConnector(application, null);
    } catch (Exception e) {
        return "Failed: " + e.getMessage();
    }

    final Connector finalConn = conn;
    ExecutorService executor = Executors.newSingleThreadExecutor();

    try {
        Callable task = new Callable() {
            public String call() {
                try {
                  SailPointContext context = SailPointFactory.createContext();  
                    finalConn.testConfiguration();
                    return "Success";
                } catch (Exception e) {
                    return "Failed: " + e.getMessage();
                }
            }
        };

        Future future = executor.submit(task);
        status = future.get(10, TimeUnit.SECONDS); // Wait for at most 10 seconds

    } catch (TimeoutException e) {
        status = "Failed: Process took too long and was ignored";
    } catch (Exception e) {
        status = "Failed: " + e.getMessage();
    } finally { 
      executor.shutdown();
    }

    return status; // if Success it will return Success
} */

  public String checkApplicationConnection(Application application) {
    String status;
    Connector conn = null;

    try {
      conn = ConnectorFactory.getConnector(application, null);
    } catch (Exception e) {
      return "Failed: " + e.getMessage();
    }

    final Connector finalConn = conn;
    ExecutorService executor = Executors.newSingleThreadExecutor();

    Callable task = new Callable() {
      public String call() {
        try {
          SailPointContext context = SailPointFactory.createContext();
          finalConn.testConfiguration();
          return "Success";
        } catch (Exception e) {
          return "Failed: " + e.getMessage();
        }
      }
    };

    try {
      Future future = executor.submit(task);
      status = future.get(10, TimeUnit.SECONDS); // Wait for at most 10 seconds
    } catch (TimeoutException e) {
      status = "Failed: Process took too long and was ignored";
    } catch (Exception e) {
      status = "Failed: " + e.getMessage();
    } finally {
      executor.shutdownNow(); // Ensure the executor service is shut down
    }

    return status;
  }

  QueryOptions qr=new QueryOptions();
  qr.addFilter(Filter.notnull("name"));
  //  Iterator itr = context.search(Application.class,qr); //Iterating all application names
  List applications = context.getObjects(Application.class,qr);
  Map map = new HashMap();
  // return itr;
  log.error("ITERATOR SEARCH : " + itr);
  for(Application application : applications){
    try{
      // Application application=itr.next();
      if(application != null){		
        applicationName= application.getName();
        applicationStatus=checkApplicationConnection(application); //passing application name one by one to checkApplicationConnection method
        log.warn("Application Name:-"+applicationName+" Status:-"+applicationStatus);
        map.put(applicationName,applicationStatus);
      }
    } catch(Exception e){
      log.error("Exception in code:-"+e.getMessage());
    }
  }
  log.warn("All Application Connection End Method");
  return map;
  ]]></Source>
</Rule>